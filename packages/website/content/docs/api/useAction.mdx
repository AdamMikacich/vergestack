---
title: useAction
---

import { AutoTypeTable } from 'fumadocs-typescript/ui';

The `useAction` hook is a powerful utility for handling asynchronous actions in React applications. It provides a convenient way to manage pending states, errors, and data responses while executing actions defined with `createAction`.

## Form Usage

The `useAction` hook can be used to handle form submissions. It provides an `executeForm` function to execute the action with a `FormData` input. Each input field is mapped within a JSON object and validated against the action's input schema. For instance, if the action expects an object with a `name` field, the form input should have a name attribute of `name`.

<Tabs items={['Greeting.tsx', 'actions.ts']}>
  <Tab value="Greeting.tsx">

    ```tsx
    import { useAction } from '@vergestack/api-react';
    import { greetingAction } from './actions';

    export function GreetingComponent() {
      const { data, errors, executeForm } = useAction(greetingAction);

      return (
        <>
          <form action={executeForm}>
            <input name="name" />
            <button type="submit">Greet</button>
          </form>

          {data && <p>Data: {data}</p>}
          {errors && <p>Errors: {errors.join(', ')}</p>}
        </>
      );
    }
    ```

  </Tab>
  <Tab value="actions.ts">
  
    ```ts
    'use server';

    import { createAction } from '@vergestack/api';
    import { z } from 'zod';

    export const greetingAction = createAction()
      .input(
        z.object({
          name: z.string()
        })
      )
      .output(z.string())
      .handler(async ({ name }) => {
        return `Hello, ${name}!`;
      });
    ```

  </Tab>
</Tabs>

<Callout title="Note">
  When working with a form, you should always use the `executeForm` helper
  unless you have a special use case.
</Callout>

## Form Error Handling

The `getFormError` function is used to retrieve form-specific errors. The function accepts a `path` argument used to match against. If an error exists with the given path, the error message is returned. If no error exists, `undefined` is returned.

An error's path is determined by the zod schema or optionally explicitly defined when throwing a custom error (see [Custom Errors](/docs/api/customErrors)).

<Tabs items={['Greeting.tsx', 'actions.ts']}>
  <Tab value="Greeting.tsx">

    ```tsx
    import { useAction } from '@vergestack/api-react';
    import { greetingAction } from './actions';

    export function GreetingComponent() {
      const { executeForm, getFormError } = useAction(greetingAction);

      return (
        <>
          <form action={executeForm}>
            <input name="name" />
            <p className="text-red-500"> // [!code highlight]
              {getFormError('name')} // [!code highlight]
            </p> // [!code highlight]
            <button type="submit">Greet</button>
          </form>
        </>
      );
    }
    ```

  </Tab>
  <Tab value="actions.ts">
  
    ```ts
    'use server';

    import { createAction } from '@vergestack/api';
    import { z } from 'zod';

    export const greetingAction = createAction()
      .input(
        z.object({
          name: z.string().min(1)
        })
      )
      .output(z.string())
      .handler(async ({ name }) => {
        return `Hello, ${name}!`;
      });
    ```

  </Tab>
</Tabs>

<Callout title="Note" type="warn">
  Registering a `getFormError` handler will cause all `onError` handlers to
  receive the `supressed` flag set to `true`.
</Callout>

<Callout title="Suggestion">
  Register a `getFormError` handler to provide inline error feedback to the user
  for fields such as an email or password. Then, use an `onError` handler to
  provide a fallback error message for all other cases. Make sure to ignore
  messages with the `supressed` flag set to `true` to avoid duplicate error
  messages.
</Callout>

## Direct Usage

The `useAction` hook can also be used directly with the `execute` function, allowing for more flexible control over when and how the action is triggered. This approach is useful when you need to perform additional logic or transformations before executing the action.

<Tabs items={['Greeting.tsx', 'actions.ts']}>
  <Tab value="Greeting.tsx">

    ```tsx
    import { useAction } from '@vergestack/api-react';
    import { greetingAction } from './actions';

    export function GreetingComponent() {
      const { data, errors, execute } = useAction(greetingAction);
      const [name, setName] = useState('');

      return (
        <>
          <input
            name="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
          <button onClick={() => execute(name)}>Greet</button>

          {data && <p>Data: {data}</p>}
          {errors && <p>Errors: {errors.join(', ')}</p>}
        </>
      );
    }
    ```

  </Tab>
  <Tab value="actions.ts">
  
    ```ts
    'use server';

    import { createAction } from '@vergestack/api';
    import { z } from 'zod';

    export const greetingAction = createAction()
      .input(z.string())
      .output(z.string())
      .handler(async (name) => {
        return `Hello, ${name}!`;
      });
    ```

  </Tab>
</Tabs>

In this example, the `execute` function is called directly when the button is clicked, passing the `name` state as an argument.

## Parameters

| Property | Type                     | Description                                                                 |
| -------- | ------------------------ | --------------------------------------------------------------------------- |
| `action` | `GeneratedActionHandler` | An action created using the `createAction` function from `@vergestack/api`. |

## Return Value

The `useAction` hook returns an object with the following properties:

| Property       | Description                                                                     |
| -------------- | ------------------------------------------------------------------------------- |
| `isPending`    | A boolean indicating whether the asynchronous operation is in progress.         |
| `isSuccess`    | A boolean indicating whether the operation completed successfully.              |
| `isError`      | A boolean indicating whether the operation resulted in an error.                |
| `errors`       | An array of `ApiErrorWithMetadata` objects if the asynchronous operation fails. |
| `data`         | The data returned by the asynchronous operation.                                |
| `status`       | The HTTP status code of the response.                                           |
| `execute`      | A function to manually trigger the execution of the asynchronous operation.     |
| `executeForm`  | A function to execute the action with `FormData` input.                         |
| `getFormError` | A function to retrieve form-specific errors (useful for inline form errors).    |

## Types

### ApiResponse

```ts
type ApiResponse<T> = ApiResponseError | ApiResponseSuccess<T>;
```

### ApiResponseSuccess

<AutoTypeTable path="content/types.ts" name="ApiResponseSuccess" />

### ApiResponseError

<AutoTypeTable path="content/types.ts" name="ApiResponseError" />

### ApiError

<AutoTypeTable path="content/types.ts" name="ApiError" />

### ApiResponseErrorCodes

```ts file="responses.ts"
import { StatusCodes } from 'http-status-codes';

type ApiResponseErrorCodes =
  | StatusCodes.BAD_REQUEST
  | StatusCodes.NOT_FOUND
  | StatusCodes.FORBIDDEN
  | StatusCodes.UNAUTHORIZED
  | StatusCodes.INTERNAL_SERVER_ERROR;
```
